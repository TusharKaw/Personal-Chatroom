{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { messageAPI } from '../../utils/api';\nconst initialState = {\n  messages: [],\n  isLoading: false,\n  isError: false,\n  errorMessage: '',\n  pagination: {\n    page: 1,\n    pages: 1,\n    total: 0\n  }\n};\n\n// Get channel messages\nexport const getChannelMessages = createAsyncThunk('message/getChannelMessages', async ({\n  channelId,\n  page = 1,\n  limit = 50\n}, {\n  rejectWithValue\n}) => {\n  try {\n    const {\n      data\n    } = await messageAPI.getChannelMessages(channelId, page, limit);\n    return data;\n  } catch (error) {\n    return rejectWithValue(error.response && error.response.data.message ? error.response.data.message : error.message);\n  }\n});\n\n// Create a new message\nexport const createMessage = createAsyncThunk('message/createMessage', async (messageData, {\n  rejectWithValue\n}) => {\n  try {\n    const {\n      data\n    } = await messageAPI.createMessage(messageData);\n    return data;\n  } catch (error) {\n    return rejectWithValue(error.response && error.response.data.message ? error.response.data.message : error.message);\n  }\n});\n\n// Delete a message\nexport const deleteMessage = createAsyncThunk('message/deleteMessage', async (id, {\n  rejectWithValue\n}) => {\n  try {\n    await messageAPI.deleteMessage(id);\n    return id;\n  } catch (error) {\n    return rejectWithValue(error.response && error.response.data.message ? error.response.data.message : error.message);\n  }\n});\nexport const messageSlice = createSlice({\n  name: 'message',\n  initialState,\n  reducers: {\n    addMessage: (state, action) => {\n      // This is for handling real-time messages from socket.io\n      state.messages.push(action.payload);\n    },\n    resetMessages: state => {\n      state.messages = [];\n      state.pagination = {\n        page: 1,\n        pages: 1,\n        total: 0\n      };\n    },\n    resetMessageError: state => {\n      state.isError = false;\n      state.errorMessage = '';\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Get channel messages\n    .addCase(getChannelMessages.pending, state => {\n      state.isLoading = true;\n    }).addCase(getChannelMessages.fulfilled, (state, action) => {\n      state.isLoading = false;\n      if (action.payload.page === 1) {\n        // Replace all messages if it's the first page\n        state.messages = action.payload.messages;\n      } else {\n        // Prepend older messages (they come in reverse chronological order)\n        state.messages = [...action.payload.messages, ...state.messages];\n      }\n      state.pagination = {\n        page: action.payload.page,\n        pages: action.payload.pages,\n        total: action.payload.total\n      };\n    }).addCase(getChannelMessages.rejected, (state, action) => {\n      state.isLoading = false;\n      state.isError = true;\n      state.errorMessage = action.payload;\n    })\n\n    // Create message\n    .addCase(createMessage.pending, state => {\n      state.isLoading = true;\n    }).addCase(createMessage.fulfilled, (state, action) => {\n      state.isLoading = false;\n      state.messages.push(action.payload);\n    }).addCase(createMessage.rejected, (state, action) => {\n      state.isLoading = false;\n      state.isError = true;\n      state.errorMessage = action.payload;\n    })\n\n    // Delete message\n    .addCase(deleteMessage.fulfilled, (state, action) => {\n      state.messages = state.messages.filter(message => message._id !== action.payload);\n    });\n  }\n});\nexport const {\n  addMessage,\n  resetMessages,\n  resetMessageError\n} = messageSlice.actions;\nexport default messageSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","messageAPI","initialState","messages","isLoading","isError","errorMessage","pagination","page","pages","total","getChannelMessages","channelId","limit","rejectWithValue","data","error","response","message","createMessage","messageData","deleteMessage","id","messageSlice","name","reducers","addMessage","state","action","push","payload","resetMessages","resetMessageError","extraReducers","builder","addCase","pending","fulfilled","rejected","filter","_id","actions","reducer"],"sources":["/Users/tusharkaw/Downloads/GIT_Porjects_v2/Personal-Chatroom/frontend/src/redux/slices/messageSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { messageAPI } from '../../utils/api';\n\nconst initialState = {\n  messages: [],\n  isLoading: false,\n  isError: false,\n  errorMessage: '',\n  pagination: {\n    page: 1,\n    pages: 1,\n    total: 0,\n  },\n};\n\n// Get channel messages\nexport const getChannelMessages = createAsyncThunk(\n  'message/getChannelMessages',\n  async ({ channelId, page = 1, limit = 50 }, { rejectWithValue }) => {\n    try {\n      const { data } = await messageAPI.getChannelMessages(channelId, page, limit);\n      return data;\n    } catch (error) {\n      return rejectWithValue(\n        error.response && error.response.data.message\n          ? error.response.data.message\n          : error.message\n      );\n    }\n  }\n);\n\n// Create a new message\nexport const createMessage = createAsyncThunk(\n  'message/createMessage',\n  async (messageData, { rejectWithValue }) => {\n    try {\n      const { data } = await messageAPI.createMessage(messageData);\n      return data;\n    } catch (error) {\n      return rejectWithValue(\n        error.response && error.response.data.message\n          ? error.response.data.message\n          : error.message\n      );\n    }\n  }\n);\n\n// Delete a message\nexport const deleteMessage = createAsyncThunk(\n  'message/deleteMessage',\n  async (id, { rejectWithValue }) => {\n    try {\n      await messageAPI.deleteMessage(id);\n      return id;\n    } catch (error) {\n      return rejectWithValue(\n        error.response && error.response.data.message\n          ? error.response.data.message\n          : error.message\n      );\n    }\n  }\n);\n\nexport const messageSlice = createSlice({\n  name: 'message',\n  initialState,\n  reducers: {\n    addMessage: (state, action) => {\n      // This is for handling real-time messages from socket.io\n      state.messages.push(action.payload);\n    },\n    resetMessages: (state) => {\n      state.messages = [];\n      state.pagination = {\n        page: 1,\n        pages: 1,\n        total: 0,\n      };\n    },\n    resetMessageError: (state) => {\n      state.isError = false;\n      state.errorMessage = '';\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Get channel messages\n      .addCase(getChannelMessages.pending, (state) => {\n        state.isLoading = true;\n      })\n      .addCase(getChannelMessages.fulfilled, (state, action) => {\n        state.isLoading = false;\n        if (action.payload.page === 1) {\n          // Replace all messages if it's the first page\n          state.messages = action.payload.messages;\n        } else {\n          // Prepend older messages (they come in reverse chronological order)\n          state.messages = [...action.payload.messages, ...state.messages];\n        }\n        state.pagination = {\n          page: action.payload.page,\n          pages: action.payload.pages,\n          total: action.payload.total,\n        };\n      })\n      .addCase(getChannelMessages.rejected, (state, action) => {\n        state.isLoading = false;\n        state.isError = true;\n        state.errorMessage = action.payload;\n      })\n      \n      // Create message\n      .addCase(createMessage.pending, (state) => {\n        state.isLoading = true;\n      })\n      .addCase(createMessage.fulfilled, (state, action) => {\n        state.isLoading = false;\n        state.messages.push(action.payload);\n      })\n      .addCase(createMessage.rejected, (state, action) => {\n        state.isLoading = false;\n        state.isError = true;\n        state.errorMessage = action.payload;\n      })\n      \n      // Delete message\n      .addCase(deleteMessage.fulfilled, (state, action) => {\n        state.messages = state.messages.filter(message => message._id !== action.payload);\n      });\n  },\n});\n\nexport const { addMessage, resetMessages, resetMessageError } = messageSlice.actions;\nexport default messageSlice.reducer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}